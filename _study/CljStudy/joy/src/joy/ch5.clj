(ns joy.ch5
  (:gen-class)
  (:require [clojure.string :as str-]))

;; > 하나의 데이터 구조에서 동작하는 100개의 함수가
;; 10개의 데이터 구조에서 동작하는 10개의 함수보다 낫다.
;; - 앨런 펄리스(Alan Perlis)

;; 이번 장의 내용
;; - 영속성, 시퀀스, 복잡성
;; - 벡터: 다양한 방법으로 생성하고 사용하기
;; - 리스트: 클로저 코드 - 구문 데이터 구조
;; - 영속적 큐 사용 방법
;; - 영속적 셋
;; - 맵으로 생각하기
;; - 시퀀스에서 아이템 위치 찾기

;; 클로저는 복합 데이터 타입과 컬렉션 타입을
;; 풍성하게 제공하고 있다. 벡터, 리스트, 큐, 셋,
;; 맵 등을 포함한 모든 내용을 다루는데, 이번 장에서는
;; 각각의 장단점을 고찰해보려 한다.
;; 특히 벡터와 맵은 광범위하게 사용되기도 하고,
;; 다른 내용을 다룰 때 필요하기도 해서 좀 더 자세히
;; 다룰 예정이다. 마지막 부분에서는 이번 장에서
;; 학습한 많은 내용들을 기반으로 한 간단한 함수를
;; 설계해볼 텐데, 인용의 쓰임새에 대한 구체적인
;; 인사이트를 얻을 수 있을 것이다.

;; 각 컬렉션 타입을 알아보기 전에 먼저 짚고 넘어갈
;; 공통적인 개념들이 있다. 예를 들어, 클로저의
;; 시퀀스 추상화에 대해 들어본 적이 있을 텐데,
;; 모든 영속적 컬렉션들은 이 개념을 사용하고 있다.
;; 이번 장을 진행하는 동안 알고리즘 복잡도 개념과
;; 함께 시퀀스 추상화를 실험해 볼 것이다.

;; 5.1 영속성, 시퀀스, 복잡성
;; 클로저의 컬렉션 데이터 타입은 다른 주요 언어들과
;; 구별되는 독특한 특성을 갖고 있다. 영속적,
;; 시퀀스 등의 용어가 사용되고는 있지만 그 의미가
;; 항상 명확하지는 않다. 이번 장에서는 조심스럽게
;; 그 의미를 정의해보려고 한다. 또한 이들이
;; 클로저 컬렉션에 적용할 때의 알고리즘 복잡도나
;; 빅오 표기법과 관련된 내용도 다루어볼 것이다.

;; 5.1.1 "계속 그 단어를 사용하시는데, 생각하는
;; 그 의미가 아닌것 같은데요."
;; 영속적이라는 용어는 요즘은 주로 디스크에 저장한다는
;; 의미로 사용되는 것이 일반적인데, 클로저에서는 좀 더
;; 구체적으로 불변하는 인메모리(in-memory) 컬렉션을
;; 사용한다는 좀 오래된 의미로 사용한다.
;; 특히 클로저에서 영속적 컬렉션은 상태의 히스토리
;; 를 저장하고 히스토리상의 각 버전들이 동일한
;; 업데이트와 조회할 때의 복잡성을 유지할 수 있도록
;; 보장한다. 이를 위한 구체적인 방법은 컬렉션 타입에
;; 따라 다른데, 이 내용들에 대해서는 각각 자세히
;; 살펴보면서 알아보기로 하자.

;; 아래 예제는 영속적 데이터 구조를 사용한 경우와
;; 자바 배열을 사용하여 영속적 데이터 구조가 아닌
;; 경우를 비교하고 있다.
(def ds (into-array [:willie :barnabas :adam]))
ds
(seq ds)

;; 이 예제는 키워드 배열의 세 항목을 생성하고,
;; seq를 사용해서 객체를 만들어 REPL상에 보여준다.
;; 배열 ds의 변화가 발생하면 그 전에 입력한 내용은
;; 모두 사라져 버린다.

(aset ds 1 :quentin)
ds
(seq ds)

;; 그러나 클로저의 영속적 데이터 구조 중 하나를 사용하면
;; 다르게 동작하는 것을 볼 수 있다.
(def ds [:willie :barnabas :adam])
ds
(def ds1 (replace {:barnabas :quentin} ds))
(seq ds)
(seq ds1)
;; 키워드 :barnabas에 대해 replace를 했지만
;; 원본 벡터인 ds는 변경되지 않고, 대신 변경된 값을
;; 저장하는 다른 벡터를 생성한다. 이러한 영속성 개념을
;; 구현할 때 보통은 각각의 변경 사항을 전체 컬렉션에
;; 복사하는 처리 속도가 느리고, 메모리를 비효율적으로
;; 사용하는 방식을 생각해볼 수도 있다. 그러나 클로저의
;; 구현에서는, 영속적 데이터 구조의 각 버전에 대한
;; 구조적 항목을 공유하는 효율적인 방식을 택하고 있다.
;; 조금은 신기해 보일 수 있는데 그 비밀에 대해서는
;; 다음 장에서 알아보기로 하고, 이번 장에서는
;; 각 컬렉션의 인스턴스가 불변하면서도 효율적으로
;; 동작한다는 점만 알고 넘어가도 충분하다.
;; 다만 이러한 원리는 값이 변경되는 전형적인
;; 컬렉션들에 대해서는 동작하지 않을 가능성이 높은데,
;; 이 중 하나가 시퀀스 추상화다.

;; 5.1.2 시퀀스 관련 용어들과 그 의미
;; 순차적(sequential), 시퀀스(sequence), 시퀀스(seq)* 등의
;; 단어들은 얼핏 보기에는 다르지 않아 보이지만, 클로저에서는
;; 다른 의미를 포함하고 있다. 먼저 각 용어들의 의미를 정의하여
;; 구분한 다음, 동일성 구획(equality partition)이나
;; 시퀀스 추상화에서 어떻게 서로 연결되는지 상세한 내용을
;; 다루기로 하자.
;; *역주: 원저에서는 Sequence와 Seq를 구별해서 사용하고 있다.
;; 한글로는 이 둘을 구분하기 쉽지 않아 동일하게
;; '시퀀스'로 번역하되 Seq의 의미를 갖는 부분에서는 '시퀀스(seq)'
;; 와 같이 표기하여 그 의미를 유지하도록 하였다.
;; 따라서 시퀀스(seq)로 표기하면 API로서의 시퀀스를
;; 의미하는 것으로 이해하면 된다.

;; 시퀀스(Seq), 순차적, 시퀀스(Sequence)..
;; 순차적 컬렉션은 일련의 값들을 재정렬하지 않고
;; 그대로 저장한다. 일반적으로 셋, 맵과 함께 널리 사용되는
;; 세 가지 컬렉션 타입의 종류 중 하나다.
;; 시퀀스(sequence)는 존재하거나 아직 존재하지 않을 수도
;; 있는 일련의 값들을 표현하는 순차적 컬렉션이다. 이 값들은
;; 실제하는 컬렉션으로부터 올 수도 있고 필요에 따라 계산된
;; 결과일 수도 있다. 또 시퀀스는 비어있을 수도 있다.

;; 클로저는 시퀀스(seq)라 불리는 컬렉션을 탐색하는 데
;; 사용되는 단순한 API를 갖고 있다. 시퀀스(seq)는
;; first와 rest 함수를 갖는다. 컬렉션에 뭔가 들어 있으면
;; (first coll)은 그 첫번째 항목을 리턴하고, 아무 것도
;; 없으면 nil을 리턴한다. (rest coll)은 첫 번째 항목을 제외한
;; 나머지 항목들의 "시퀀스"를 리턴한다. 만일 첫 번째 외에
;; 다른 항목이 없어도 rest는 절대 nill을 리턴하지 않고,
;; 대신 빈 시퀀스를 리턴한다. 3.1절과 3.2절을 상기해보면
;; 클로저에서 nil과 빈 컬렉션을 다루는 방법은 클로저의
;; 반복 패턴을 활용하는 것이다. map이나 filter와 같이
;; 시퀀스를 리턴하는 클로저 함수들은 rest와 같은 방식으로
;; 동작한다. 시퀀스(seq) API를 구현한 객체들도 시퀀스(seq)
;; 이므로 당연히 first와 rest를 지원한다.
;; 내부 상태를 거의 제한 없이 병행, 병렬로 반복할 수
;; 있다는 점을 제외하면 불변성을 가진 열거자(enumerator)
;; 와 반복자(iterator)의 변종 정도로 생각해볼 수도 있다.

;; 이 책에서는 클로저의 특성과 관련한 용어에 대해서는
;; 정확한 용어를 사용하려 노력할 것이다.
;; 표 5.1에 컬렉션과 관련한 몇 가지 용어들을 요약해 두었다.
;; <표>
;; 컬렉션 - 복합 데이터 타입 - [1 2], {:a 1}, #{1 2}, 리스트, 배열
;; 순차적(Sequential) 컬렉션 - 정렬된 일련의 값들 - [1 2 3 4], (1 2 3 4)
;; 시퀀스(Sequence) - 존재하거나 아직 존재하지 않을 수도 있는 순차적 컬렉션 - (map func coll)의 결과
;; 시퀀스(Seq) - 컬렉션 탐색을 위한 간단한 API - first, rest nil, ()
;; clojure.core/seq - 시퀀스(seq) API를 구현한 객체를 리턴하는 함수 - (seq []) => nil, (seq [1 2]) => (1 2)
(seq [])
(seq [1 2])

;; 컬렉션과 비슷한 타입의 다양한 객체를 취할 수 있는 seq 함수도 있다.
;; 리스트와 같은 몇몇 컬렉션들은 시퀀스(seq) API를 직접 구현하고 있어서
;; seq 함수에서 이들을 호출하면 컬렉션 자체를 리턴한다. 대부분의 경우에는
;; seq에서 컬렉션을 호출하면 그 컬렉션을 탐색하기 위한 새 시퀀스(seq) 객체를
;; 리턴하고, 빈 시퀀스를 리턴하지는 않는다. next처럼 시퀀스(seq)를
;; 리턴하는 함수들은 같은 방식으로 동작한다.
;; 클로저의 시퀀스 라이브러리는 seq 함수와 시퀀스(seq) API를 사용함으로써
;; 컬렉션, 문자열, 배열 등을 마치 시퀀스인 것처럼 다룰 수 있게 해준다.

;; 동일성 구획

;; 앞서 언급한 것처럼 클로저는 각 컬렉션 데이터 타입을 순차적 컬렉션, 맵
;; ,셋의 세 가지 논리적 카테고리로 구분한다. 이러한 구분은 타입들 간의
;; 명확한 구분과 동일성 여부를 결정하는 데 도움을 준다. 특히 어떤 두 객체가
;; 서로 다른 카테고리에 속해 있다면 절대 같을 수 없다. 벡터 같은 몇가지
;; 컬렉션은 순차적 컬렉션이지만, 몇가지 타입들은 실제로는 시퀀스인
;; 경우도 있다.

;; 만일 두 순차적 컬렉션이 같은 순서로 같은 값을 갖고 있다면 둘의 실제 타입이 다르더라도 =는 true를 리턴할 것이다.

(= [1 2 3] '(1 2 3))

;; 반대로 두 컬렉션이 정확하게 같은 값을 가지고 있다고 해도 하나는 순차적 컬렉션이고 다른 하나는 그렇지 않은 경우, =는 false를 리턴한다.

(= [1 2 3] #{1 2 3})

;; 많은 리습 계열 언어들은 cons 셀 추상화를 기반으로 각자의 데이터 타입을 만든다(McCarthy 1962). Cons 셀 추상화는 그림5.1과 같이 두 항목 간의 연결 구조로 표현할 수 있다. Cons 셀은 자바 코어 라이브러리의 java.util.LinkedList 타입과 유사한 링크드 리스트 구조로 이루어져 있다. 전통적인 리습이 cons 셀 구조를 기반에 두고 있다고는 하지만, 사실 리습 이름 자체는 리스트 프로세싱(list processing)에서 따온 것이다.

;; > 그림5.1 각 cons 셀은 car와 cdr이라 불리는 단순한 구조의 쌍으로 이루어져 있다. (A) 리스트는 x와 y 값을 갖는 두 셀(cell)로 이루어져 있고, 각각 head(리습용어로는 car)와 tail(리습용어로는 cdr)이 된다. 이 구조는 클로저 시퀀스의 first와 rest의 개념과 상당히 유사하다. (B) head와 tail을 함께 간단한 값으로 갖는 cons 셀은 점 쌍(dotted pair)이라 불리는데, 클로저에 내장된 타입들은 이 구조를 지원하지 않는다.
;; 클로저도 cons 셀 쌍과 유사한 구조를 갖고 있다. 이에 대해서는 5.4절에서 알아볼 것이지만, 이것이 클로저 설계의 근간을 이루고 있지는 않다. 그대신 cons 셀에 의해 만들어진 개념적 인터페이스가 앞서 설명했던 시퀀스라 불리는 실제적인 구조를 뒷받침하고 있다. 이 구조의 핵심적인 두 함수 first와 rest를 지원하려면 모든 객체가 시퀀스일 필요가 있다. 그러나 filter, map, for, doseq, take, partition, 그 외에도 수많은 클로저가 제공하는 강력한 시퀀스 함수 라이브러리와 컬렉션에 사용 가능한 매크로 등이 제공되는 것을 생각하면 그리 과한 조건은 아니다.
;; 이와 동시에 많은 객체들이 이 인터페이스를 이미 따르고 있다. 모든 클로저 컬렉션들은 그 항목들을 탐색하기 위한 시퀀스(seq) 객체를 적어도 하나는 제공하고 있고, 이를 seq 함수를 통해 노출시킨다. 어떤 컬렉션은 한 개 이상을 제공하기도 한다. 예를 들어 벡터는 rseq를 지원하고, 맵은 keys와 vals를 제공한다. 이 모든 함수들은 Seq를 리턴하거나 컬렉션이 비어 있으면 nil을 리턴한다.
;; 타입을 조회할 때 리턴되는 객체의 다양한 표현에서 이에 대한 예를 발견할 수 있다. 맵 클래스를 한 번 살펴보자.

(class (hash-map :a 1))

;; hash-map 함수가 PersistentHashMap 타입 객체를 리턴하는 것은 그리 놀랍지 않다. 이번에는 그 맵 객체를 seq에 넘겨서 새 객체를 리턴해 보자.
(seq (hash-map :a 1))

(class (seq (hash-map :a 1)))

;; 이 클래스명은 해시 맵에 있는 노드들의 시퀀스라는 것을 보여준다. 이와 유사하게 같은 맵에 대해서 키의 Seq를 얻을 수도 있다.
(seq (keys (hash-map :a 1)))

(class (keys (hash-map :a 1)))