(ns joy.ch5
  (:gen-class)
  (:require [clojure.string :as str-]))

;; > 하나의 데이터 구조에서 동작하는 100개의 함수가
;; 10개의 데이터 구조에서 동작하는 10개의 함수보다 낫다.
;; - 앨런 펄리스(Alan Perlis)

;; 이번 장의 내용
;; - 영속성, 시퀀스, 복잡성
;; - 벡터: 다양한 방법으로 생성하고 사용하기
;; - 리스트: 클로저 코드 - 구문 데이터 구조
;; - 영속적 큐 사용 방법
;; - 영속적 셋
;; - 맵으로 생각하기
;; - 시퀀스에서 아이템 위치 찾기

;; 클로저는 복합 데이터 타입과 컬렉션 타입을
;; 풍성하게 제공하고 있다. 벡터, 리스트, 큐, 셋,
;; 맵 등을 포함한 모든 내용을 다루는데, 이번 장에서는
;; 각각의 장단점을 고찰해보려 한다.
;; 특히 벡터와 맵은 광범위하게 사용되기도 하고,
;; 다른 내용을 다룰 때 필요하기도 해서 좀 더 자세히
;; 다룰 예정이다. 마지막 부분에서는 이번 장에서
;; 학습한 많은 내용들을 기반으로 한 간단한 함수를
;; 설계해볼 텐데, 인용의 쓰임새에 대한 구체적인
;; 인사이트를 얻을 수 있을 것이다.

;; 각 컬렉션 타입을 알아보기 전에 먼저 짚고 넘어갈
;; 공통적인 개념들이 있다. 예를 들어, 클로저의
;; 시퀀스 추상화에 대해 들어본 적이 있을 텐데,
;; 모든 영속적 컬렉션들은 이 개념을 사용하고 있다.
;; 이번 장을 진행하는 동안 알고리즘 복잡도 개념과
;; 함께 시퀀스 추상화를 실험해 볼 것이다.

;; 5.1 영속성, 시퀀스, 복잡성
;; 클로저의 컬렉션 데이터 타입은 다른 주요 언어들과
;; 구별되는 독특한 특성을 갖고 있다. 영속적,
;; 시퀀스 등의 용어가 사용되고는 있지만 그 의미가
;; 항상 명확하지는 않다. 이번 장에서는 조심스럽게
;; 그 의미를 정의해보려고 한다. 또한 이들이
;; 클로저 컬렉션에 적용할 때의 알고리즘 복잡도나
;; 빅오 표기법과 관련된 내용도 다루어볼 것이다.

;; 5.1.1 "계속 그 단어를 사용하시는데, 생각하는
;; 그 의미가 아닌것 같은데요."
;; 영속적이라는 용어는 요즘은 주로 디스크에 저장한다는
;; 의미로 사용되는 것이 일반적인데, 클로저에서는 좀 더
;; 구체적으로 불변하는 인메모리(in-memory) 컬렉션을
;; 사용한다는 좀 오래된 의미로 사용한다.
;; 특히 클로저에서 영속적 컬렉션은 상태의 히스토리
;; 를 저장하고 히스토리상의 각 버전들이 동일한
;; 업데이트와 조회할 때의 복잡성을 유지할 수 있도록
;; 보장한다. 이를 위한 구체적인 방법은 컬렉션 타입에
;; 따라 다른데, 이 내용들에 대해서는 각각 자세히
;; 살펴보면서 알아보기로 하자.

;; 아래 예제는 영속적 데이터 구조를 사용한 경우와
;; 자바 배열을 사용하여 영속적 데이터 구조가 아닌
;; 경우를 비교하고 있다.
(def ds (into-array [:willie :barnabas :adam]))
ds
(seq ds)

;; 이 예제는 키워드 배열의 세 항목을 생성하고,
;; seq를 사용해서 객체를 만들어 REPL상에 보여준다.
;; 배열 ds의 변화가 발생하면 그 전에 입력한 내용은
;; 모두 사라져 버린다.

(aset ds 1 :quentin)
ds
(seq ds)

;; 그러나 클로저의 영속적 데이터 구조 중 하나를 사용하면
;; 다르게 동작하는 것을 볼 수 있다.
(def ds [:willie :barnabas :adam])
ds
(def ds1 (replace {:barnabas :quentin} ds))
(seq ds)
(seq ds1)
;; 키워드 :barnabas에 대해 replace를 했지만
;; 원본 벡터인 ds는 변경되지 않고, 대신 변경된 값을
;; 저장하는 다른 벡터를 생성한다. 이러한 영속성 개념을
;; 구현할 때 보통은 각각의 변경 사항을 전체 컬렉션에
;; 복사하는 처리 속도가 느리고, 메모리를 비효율적으로
;; 사용하는 방식을 생각해볼 수도 있다. 그러나 클로저의
;; 구현에서는, 영속적 데이터 구조의 각 버전에 대한
;; 구조적 항목을 공유하는 효율적인 방식을 택하고 있다.
;; 조금은 신기해 보일 수 있는데 그 비밀에 대해서는
;; 다음 장에서 알아보기로 하고, 이번 장에서는
;; 각 컬렉션의 인스턴스가 불변하면서도 효율적으로
;; 동작한다는 점만 알고 넘어가도 충분하다.
;; 다만 이러한 원리는 값이 변경되는 전형적인
;; 컬렉션들에 대해서는 동작하지 않을 가능성이 높은데,
;; 이 중 하나가 시퀀스 추상화다.