(ns joy.ch5_2
  (:gen-class)
  (:require [clojure.string :as str-]))

;; ### 5.2.1 벡터 만들기

;; 벡터가 꺽쇠 괄호([ ]) 문법을 사용하는 것은 배열에서 벡터를 사용하게 만드는 이유가 되기도 한다. 만일 문자 벡터 대신 문자 배열 바인딩을 사용한다면 let 구문을 사용하는 것과 거의 동일한 구현으로 완벽하게 잘 동작한다. 그러나 꺽쇠 괄호는 let 구문 자체를 둘러싸고 있는 일반적인 괄호와는 다르게 생겼을 뿐만 아니라 let 구문의 몸체로부터 함수를 호출하는 것과도 비슷해서 유용하게 사용될 수 있다. let, with-open, fn 등 바인딩 선언의 용도로 벡터를 사용하는 것은 클로저에 맞는 활용 방법이자 비슷한 매크로를 작성할 때도 따르기를 권장하는 패턴이다.

;; 벡터를 생성하는 가장 일반적인 방법은 [1 2 3] 과 같은 문법을 사용하는 것이다.
;; 그러나 많은 경우에서 다른 종류의 컬렉션 타입으로 선언된 벡터 외부 값들로 생성하고 싶을 때도 있다.
;; 이런 때는 vec 함수를 사용한다.

(vec (range 10))

(class (range 10))

;; 이미 생성된 벡터에 다른 값들을 넣고 싶으면 into를 사용하면 된다.
;; 
(let [my-vector [:a :b :c]]
  (into my-vector (range 10)))

;; 벡터를 리턴하고 싶으면 into의 첫 번째 인자가 벡터이어야 한다. 두 번째 인자는 어떤 시퀀스든 상관없다. range가 리턴하는 값이거나 seq함수와 동작하는 어떤 것이어도 된다. into의 동작은 두 번째 인자의 크기에 기반을 두고 연결하는 O (n) 과 유사하다. 또한 클로저는 vector 함수를 제공하고 있어서 (map vector a b) 와 인자들로부터 편리하게 벡터를 생성할 수 있다.
(map vector [1] [2])
(vec '(1 2))

;; 클로저는 vector-of를 사용하여 벡터에 다른 기본 타입들을 저장할 수 있다. vector-of에 :int, :long, :float, :double, :byte, :short, :boolean, :char를 인자로 넣으면 비어있는 벡터를 리턴한다. 이 리턴된 벡터는 내부적으로 그 내용을 기본 타입으로 저장하는 경우가 아니라면 다른 벡터들과 동일하게 동작한다. 모든 일반적인 벡터 연산들도 잘 적용되고, 새 벡터를 추가할 때는 내부 타입으로 강제적으로 변환하여 추가한다.

(into (vector-of :int) [Math/PI 2 1.3])

(into (vector-of :char) [100 101 102])

(into (vector-of :int) [1 2 6238763712678132673])

;; 5.2.2 큰 벡터
;; 컬렉션의 크기가 작을 때는 벡터와 리스트 간의 성능 차이가 거의 나지 않는다. 그러나 둘의 크기가 커지면 한 쪽은 효율적으로 동작하는 반면 다른 한 쪽은 극적으로 느려지게 된다. 벡터는 특히 컬렉션의 오른쪽 끝에 항목을 추가/삭제하는 경우와 숫자 인덱스로 컬렉션 내부 항목에 접근하거나 변경하는 경우, 그리고 역순으로 조회하는 이 세 가지 경우에는 리스트에 비해 효율적으로 동작한다. 끝부분에 항목을 추가하거나 삭제하는 것은 벡터를 스택으로 취급하면 되는데, 5.2.3절에서 설명할 것이다.
;; 벡터의 어떤 항목이라도 0에서 (count my-vector)를 제외한 그 사이의 값을 갖는 숫자 인덱스를 사용하면 본질적으로는 상수 시간 안에 접근할 수 있다. (이 책에서 클로저의 영속적 데이터 구조에 대한 몇 가지 연산의 복잡도는 “본질적으로는 상수 시간” 이라는 표현을 사용한다. 모든 경우에서 이들은 O(log32 n)의 복잡성을 갖는다.) 그 방법은 nth 함수를 사용하는 것이고, get 함수를 사용하면 벡터를 맵처럼 다룰 수도 있다. 또는 벡터를 함수처럼 호출하는 방법도 있다. 각 방법에 대한 아래 예제를 살펴보자.

(def a-to-j (vec (map char (range 65 75))))
a-to-j

;; 아래 세 가지 모두 동일하게 \E를 리턴한다.
(nth a-to-j 4)

(get a-to-j 4)

(a-to-j 4)

;; 어떤 것을 사용해야 할 지 평가해 보면 알 수 있겠지만, 표 5.2에 이 선택에 도움이 될만한 몇가지 내용을 강조해 두었다.

;; > 표5.2 벡터 조회 방법 비교: 벡터의 항목을 조회하는 세 가지 방법과 예외적인 상황에서 각각 어떻게 다르게 동작하는지 비교했다.
;; |  | nth | get | 함수로서의 벡터 |
;; | --- | --- | --- | --- |
;; | 벡터가 nil인 경우 | nil 리턴 | nil 리턴 | 예외 발생 |
;; | 인덱스 범위 밖인 경우 | 예외 발생 또는 “not found” 리턴 | nil 리턴 | 예외 발생 |
;; | “not found” 인자 지원 여부 | 지원
;; (nth [] 9 :whoops) | 지원
;; (get [] 9 :whoops) | 미지원 |

(nth a-to-j 10)
(get a-to-j 10)

;; 벡터는 색인되어 있기 때문에 좌우 어떤 방향으로든 효율적으로 동작한다. seq와 rseq 함수는 정확히 이런 동작을 하고 시퀀스를 리턴한다.
(seq a-to-j)

(rseq a-to-j)