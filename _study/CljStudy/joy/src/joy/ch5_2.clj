(ns joy.ch5_2
  (:gen-class)
  (:require [clojure.string :as str-]))

;; ### 5.2.1 벡터 만들기

;; 벡터가 꺽쇠 괄호([ ]) 문법을 사용하는 것은 배열에서 벡터를 사용하게 만드는 이유가 되기도 한다. 만일 문자 벡터 대신 문자 배열 바인딩을 사용한다면 let 구문을 사용하는 것과 거의 동일한 구현으로 완벽하게 잘 동작한다. 그러나 꺽쇠 괄호는 let 구문 자체를 둘러싸고 있는 일반적인 괄호와는 다르게 생겼을 뿐만 아니라 let 구문의 몸체로부터 함수를 호출하는 것과도 비슷해서 유용하게 사용될 수 있다. let, with-open, fn 등 바인딩 선언의 용도로 벡터를 사용하는 것은 클로저에 맞는 활용 방법이자 비슷한 매크로를 작성할 때도 따르기를 권장하는 패턴이다.

;; 벡터를 생성하는 가장 일반적인 방법은 [1 2 3] 과 같은 문법을 사용하는 것이다.
;; 그러나 많은 경우에서 다른 종류의 컬렉션 타입으로 선언된 벡터 외부 값들로 생성하고 싶을 때도 있다.
;; 이런 때는 vec 함수를 사용한다.

(vec (range 10))

(class (range 10))

;; 이미 생성된 벡터에 다른 값들을 넣고 싶으면 into를 사용하면 된다.
;; 
(let [my-vector [:a :b :c]]
  (into my-vector (range 10)))

;; 벡터를 리턴하고 싶으면 into의 첫 번째 인자가 벡터이어야 한다. 두 번째 인자는 어떤 시퀀스든 상관없다. range가 리턴하는 값이거나 seq함수와 동작하는 어떤 것이어도 된다. into의 동작은 두 번째 인자의 크기에 기반을 두고 연결하는 O (n) 과 유사하다. 또한 클로저는 vector 함수를 제공하고 있어서 (map vector a b) 와 인자들로부터 편리하게 벡터를 생성할 수 있다.
(map vector [1] [2])
(vec '(1 2))

;; 클로저는 vector-of를 사용하여 벡터에 다른 기본 타입들을 저장할 수 있다. vector-of에 :int, :long, :float, :double, :byte, :short, :boolean, :char를 인자로 넣으면 비어있는 벡터를 리턴한다. 이 리턴된 벡터는 내부적으로 그 내용을 기본 타입으로 저장하는 경우가 아니라면 다른 벡터들과 동일하게 동작한다. 모든 일반적인 벡터 연산들도 잘 적용되고, 새 벡터를 추가할 때는 내부 타입으로 강제적으로 변환하여 추가한다.

(into (vector-of :int) [Math/PI 2 1.3])

(into (vector-of :char) [100 101 102])

(into (vector-of :int) [1 2 6238763712678132673])

;; 5.2.2 큰 벡터
;; 컬렉션의 크기가 작을 때는 벡터와 리스트 간의 성능 차이가 거의 나지 않는다. 그러나 둘의 크기가 커지면 한 쪽은 효율적으로 동작하는 반면 다른 한 쪽은 극적으로 느려지게 된다. 벡터는 특히 컬렉션의 오른쪽 끝에 항목을 추가/삭제하는 경우와 숫자 인덱스로 컬렉션 내부 항목에 접근하거나 변경하는 경우, 그리고 역순으로 조회하는 이 세 가지 경우에는 리스트에 비해 효율적으로 동작한다. 끝부분에 항목을 추가하거나 삭제하는 것은 벡터를 스택으로 취급하면 되는데, 5.2.3절에서 설명할 것이다.
;; 벡터의 어떤 항목이라도 0에서 (count my-vector)를 제외한 그 사이의 값을 갖는 숫자 인덱스를 사용하면 본질적으로는 상수 시간 안에 접근할 수 있다. (이 책에서 클로저의 영속적 데이터 구조에 대한 몇 가지 연산의 복잡도는 “본질적으로는 상수 시간” 이라는 표현을 사용한다. 모든 경우에서 이들은 O(log32 n)의 복잡성을 갖는다.) 그 방법은 nth 함수를 사용하는 것이고, get 함수를 사용하면 벡터를 맵처럼 다룰 수도 있다. 또는 벡터를 함수처럼 호출하는 방법도 있다. 각 방법에 대한 아래 예제를 살펴보자.

(def a-to-j (vec (map char (range 65 75))))
a-to-j

;; 아래 세 가지 모두 동일하게 \E를 리턴한다.
(nth a-to-j 4)

(get a-to-j 4)

(a-to-j 4)

;; 어떤 것을 사용해야 할 지 평가해 보면 알 수 있겠지만, 표 5.2에 이 선택에 도움이 될만한 몇가지 내용을 강조해 두었다.

;; > 표5.2 벡터 조회 방법 비교: 벡터의 항목을 조회하는 세 가지 방법과 예외적인 상황에서 각각 어떻게 다르게 동작하는지 비교했다.
;; |  | nth | get | 함수로서의 벡터 |
;; | --- | --- | --- | --- |
;; | 벡터가 nil인 경우 | nil 리턴 | nil 리턴 | 예외 발생 |
;; | 인덱스 범위 밖인 경우 | 예외 발생 또는 “not found” 리턴 | nil 리턴 | 예외 발생 |
;; | “not found” 인자 지원 여부 | 지원
;; (nth [] 9 :whoops) | 지원
;; (get [] 9 :whoops) | 미지원 |

(nth a-to-j 10)
(get a-to-j 10)

;; 벡터는 색인되어 있기 때문에 좌우 어떤 방향으로든 효율적으로 동작한다. seq와 rseq 함수는 정확히 이런 동작을 하고 시퀀스를 리턴한다.
(seq a-to-j)

(rseq a-to-j)

;; 벡터 내의 항목은 assoc 함수를 사용해서 변경할 수 있다. 클로저는 이 장의 초반에 설명했던 것과 같이 이전 벡터와 새 벡터 간의 구조 공유를 통해 본질적으로 상수 시간 안에 값 변경을 수행한다.
(assoc a-to-j 4 "no longer E")

;; assoc 함수는 벡터에 이미 정의된 인덱스상에서만 동작하거나 특별하게는 벡터의 맨 끝에서도 동작하는데, 이 경우에는 리턴된 벡터는 입력된 벡터보다 한 항목이 더 늘어나게 된다. 벡터의 크기를 증가시킬 때는 보통 다음 절에서 보게 될 conj 함수를 더 자주 사용한다.
;; 몇 가지 고차 함수에서는 내부적으로 assoc 함수를 사용한다. 예를 들면 replace 함수는 시퀀스와 벡터에 사용할 수 있는데, 벡터의 경우에는 수정된 새 벡터를 리턴하는 데 assoc 함수가 사용된다.
(replace {2 :a, 4 :b} [1 2 3 2 3 4])

;; assoc-in 함수와 update-in 함수는 다음과 같이 벡터와 맵의 내부 구조에서 사용된다.
;; (내부 벡터가 행렬을 저장하고 처리하기 위한 효율적인 방법이라고 말하기는 어렵지만, 클로저에서는 편리하게 처리할 수 있어서 예제로 사용하기에는 좋다. 더 효율적인 방법으로는 단일 벡터나 배열, 또는 Colt나 Incanter(http://incanter.org)와 같은 행렬 처리 라이브러리 등이 있다.)
(def matrix
  [[1 2 3]
   [4 5 6]
   [7 8 9]])

;; assoc-in, get-in, update-in 등은 인덱스 목록을 받아서 주어진 객체의 내부 구조의 항목에 접근한다. 위 matrix 예제처럼 정렬된 벡터의 경우는 행렬 좌표와 같은 역할을 한다.
(get-in matrix [1 2])

(assoc-in matrix [1 2] 'x)

;; update-in 함수도 같은 방식으로 동작하지만, 덮어씌울 기존 값을 선택해서 apply 함수를 적용한다. 이렇게 하면 해당 좌표의 값에 주어진 함수를 적용한 값으로 대체된다.
(update-in matrix [1 2] * 100)

;; 좌표는 6을 가리키고 * 함수에 인자로 100이 입력되어 해당 위치에 (* 6 100)의 값을 리턴한다. 내부 벡터를 탐색하는 함수에는 get-in도 있다. get-in의 동작을 살펴보기 전에 다음 예제와 같이 2차원 행렬에서 y-x 위치가 주어지면 그 좌표에 대한 이웃들로 구성된 시퀀스를 리턴하는 neighbors 함수를 만들어 보자.

;; 예제 5.1: 2차원 행렬의 특정 좌표에 대한 이웃을 찾는 함수

(defn neighbors
  ([size yx] (neighbors [[-1 0] [1 0] [0 -1] [0 1]]
                        size
                        yx))
  ([deltas size yx]
   (filter (fn [new-yx]
             (every? #(< -1 % size) new-yx))
           (map #(vec (map + yx %))
                deltas))))
;; neighbors의 동작은 꽤 단순하다. 한 번 천천히 살펴보자. 먼저 deltas는 한 지점에 해당하는 x와 y 방향의 대각선을 제외한 이웃들을 기술한다. 이 함수는 deltas를 탐색하면서 각각에 yx를 더한 벡터를 만든다. 이 과정에서 적절하지 않은 좌표들도 생성되므로, 인덱스들이 -1과 size 사이에 있는지 확인하는 filter를 사용해서 제거한다.

;; 이 동작을 확인해보기 위해 neighbors 를 호출해서 3 x 3 행렬의 좌측상단 칸의 이웃을 조회해보자.


(neighbors 3 [0 0])

;; 결과는 y=0|x=0 칸에 대한 이웃은 y=1|x=0과 y=0|x=1 이라고 말하고 있다.

;; 이번에는 neighbors를 호출해서 같은 크기의 행렬의 정가운데 칸에 대한 이웃을 조회해 보자.
(neighbors 3 [1 1])

;; 이 결과에서는 y=1|x=1의 십자 방향 이웃은 그림 5.4와 같이 더하기 기호 같은 모양이 된다.

;; 이번에는 (0,0) 칸에 대한 neighbors를 다음과 같이 get-in으로 테스트 해보자.
(map #(get-in matrix %) (neighbors 3 [0 0]))

(get-in matrix [1 2])