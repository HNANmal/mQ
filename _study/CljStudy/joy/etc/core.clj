;; (ns joy.core
;;   (:gen-class)
;;   (:require [clojure.string :as str-]))


;; ;; 3.3 구조분해
;; ;; 2장에서 클로저에 내장된 작은 언어라고 할 수 있는
;; ;; 클로저의 구조분해에 대해서 간단하게 언급했다.
;; ;; 구조분해는 복합 데이터 구조(composite data structure)
;; ;; 에서 특정 구문을 로컬에 바인딩할 수 있도록 해준다.
;; ;; 이번 절에서는 간단한 롤로덱스(회전식 명함정리기)
;; ;; 예제 프로젝트를 통해 복합 구조를 분해하고 바인딩
;; ;; 하는 방법을 알아본다.

;; ;; 3.3.1 이 일 해야 돼 말아야 돼?
;; ;; 여러분은 롤로덱스 프로젝트가 이미 지연되었다는
;; ;; 얘기를 들었다. 그러나 이 프로젝트에 투입된
;; ;; 모든 개발자가 다 몸 상태가 좋지 않다. QA팀은
;; ;; 개발이 끝나기를 기다리고 있는데 아직 한가지 기능은
;; ;; 완료되지 않은데다가 치명적인 버그가 있다.
;; ;; 여러분에게는 모든 일을 다 중단하고 당장 그 기능을
;; ;; 구현하라는 업무 지시가 떨어진 상황이다.

;; ;; 설계는? 길이가 3인 벡터로 사람의 이름, 중간이름,
;; ;; 성을 표현하고 "Steele, Guy Lewis"와 같은
;; ;; 일반적인 방식으로 정렬된 문자열을 리턴해야 한다.
;; ;; 뭘 우물쭈물 기다리고 있는가? 대체 왜 아직도
;; ;; 못 끝내고 있느냐는 말이다?!?!

;; (def guys-whole-name ["Guy" "Lewis" "Steele"])

;; (str (nth guys-whole-name 2) ", "
;;      (nth guys-whole-name 0) " "
;;      (nth guys-whole-name 1))

;; ;; 어허 이런, 이 코드를 마칠 때까지 guy-whole-name를
;; ;; 4번이나 사용했다. 하지만 깨닫기엔 너무 늦었다.
;; ;; 고객은 이미 주문을 취소했고, 여러분이 속한 전체
;; ;; 부서도 축소되어버렸다.
;; ;; 만일 여러분이 구조분해에 대해 알고 있었다고
;; ;; 가정해보자.
;; ;; 좋다. 여러분이 작성한 함수가 필요한 라인 수보다
;; ;; 두 배나 되니 실직 위험은 없을 것 같지만
;; ;; 아주 작은 함수임에도 코드 반복이 너무나 많다.
;; ;; 그리고 로컬 이름을 사용하지 않고 인덱스 숫자를 사용해서
;; ;; 함수가 어떤 목적으로 작성된 것인지 알기가 어렵다.
;; ;; 구조분해는 보통은 단일한 이름을 명시하는 부분에
;; ;; 이름 컬렉션을 바인딩 구문에 두어서 이런 문제들을
;; ;; 해결할 수 있도록 해준다. 함수를 정의할 때 인자 리스트를
;; ;; 나열하는 부분이 바인딩 구문의 한 종류다.

;; ;; 3.3.2 벡터로 구조분해하기
;; ;; 이번에는 Guy의 이름 각 부분을 사용하기
;; ;; 좀 더 편리하게 만들기 위해 let으로 구조분해해서
;; ;; 로컬을 생성해보자.

;; (let [[f-name m-name l-name] guys-whole-name]
;;   (str l-name ", " f-name " " m-name))

;; ;; ;; 위치 구조분해는 맵이나 셋에 대해서는 동작하지
;; ;; ;; 않는다. 맵과 셋은 논리적인 순차 정렬이 되지 않기
;; ;; ;; 때문이다. 재미있게도 위치 구조분해는 자바의
;; ;; ;; java.util.regex.Matcher에도 동작한다.
;; (def date-regex #"(\d{1,2})\/(\d{1,2})\/(\d{4})")
;; (let [rem (re-matcher date-regex "12/02/1975")]
;;   (when (.find rem)
;;     (let [[_ m d] rem]
;;       {:month m :day d})))

;; ;; 이것은 순차적인 것들(이 경우엔 문자열 벡터가 이에
;; ;; 해당한다. 물론 다른 순차적 컬렉션에 대해서도
;; ;; 동작한다)을 골라내서 각 항목에 이름을 부여하고
;; ;; 싶을 때 사용할 수 있는 가장 간단한 형태의
;; ;; 구조분해 구문이다.
;; ;; 여기서는 필요하지 않지만, 구조분해 벡터에 입력될
;; ;; 인자의 나머지 값들(아마도 지연 시퀀스로 입력될)을
;; ;; 참조하기 위해 앰퍼샌드(&)를 사용할 수도 있다.

;; (let [[a b c & more] (range 10)]
;;   (println "a b c are:" a b c)
;;   (println "more is:" more))
;; ;; 여기서 로컬 a, b, c가 생성되어 range의 처음
;; ;; 세 개 값이 바인딩된다. 다음 심벌은 앰퍼샌드 이므로
;; ;; 나머지 값들은 more에 바인딩되어 시퀀스로
;; ;; 사용할 수 있다.

;; (let [range-vec (vec (range 10))
;;       [a b c & more :as all] range-vec]
;;   (println "a b c are:" a b c)
;;   (println "more is:" more)
;;   (println "all is:" all))

;; ;; 이 예제에서 range-vec는 벡터고 :as 명령은
;; ;; 입력된 컬렉션 그대로를 바인딩하여 벡터가
;; ;; 벡터로 유지되도록 한다. 반대로 &는 more를
;; ;; 벡터가 아닌 시퀀스로 바인딩한다.


;; (defn -main
;;   "I don't do a whole lot ... yet."
;;   [& args])